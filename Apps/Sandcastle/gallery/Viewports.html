<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
    <meta name="description" content="Add multiple viewports">
    <meta name="cesium-sandcastle-labels" content="Beginner, Showcases">
    <title>Cesium Demo</title>
    <script type="text/javascript" src="../Sandcastle-header.js"></script>
    <script type="text/javascript" src="../../../ThirdParty/requirejs-2.1.20/require.js"></script>
    <script type="text/javascript">
    require.config({
        baseUrl : '../../../Source',
        waitSeconds : 60
    });
    </script>
</head>
<body class="sandcastle-loading" data-sandcastle-bucket="bucket-requirejs.html">
<style>
    @import url(../templates/bucket.css);
</style>
<div id="cesiumContainer" class="fullSize"></div>
<div id="loadingOverlay"><h1>Loading...</h1></div>
<div id="toolbar"></div>
<script id="cesium_sandcastle_script">
function startup(Cesium) {
    'use strict';
//Sandcastle_Begin
var viewer = new Cesium.Viewer('cesiumContainer');
var widget = viewer.cesiumWidget;
var sceneManager = widget._sceneManager;

var scene0 = sceneManager.get(0);
var scene1 = sceneManager.add({
    mapProjection : scene0.mapProjection,
    orderIndependentTranslucency : scene0.orderIndependentTranslucency,
    scene3DOnly : scene0.scene3DOnly,
    terrainExaggeration : scene0.terrainExaggeration,
    shadows : scene0.shadows,
    mapMode2D : scene0.mapMode2D
});

var ellipsoid = scene1.mapProjection.ellipsoid;
scene1.globe = new Cesium.Globe(ellipsoid);
scene1.skyAtmosphere = scene0.skyAtmosphere;
scene1.skyBox = scene0.skyBox;
scene1.sun = scene0.sun;
scene1.moon = scene0.moon;
scene1.imageryLayers.addImageryProvider(new Cesium.BingMapsImageryProvider({
    url : 'https://dev.virtualearth.net'
}));

//scene1.morphToColumbusView(0);
scene1.morphTo2D(0);

function resize() {
    var context = sceneManager.context;

    var viewport = new Cesium.BoundingRectangle();
    viewport.x = context.drawingBufferWidth * 0.1;
    viewport.y = context.drawingBufferHeight * 0.1;
    viewport.width = context.drawingBufferWidth - context.drawingBufferWidth * 0.2;
    viewport.height = context.drawingBufferHeight - context.drawingBufferHeight * 0.2;

    scene0.viewport = viewport;

    viewport = new Cesium.BoundingRectangle();
    viewport.x = scene0.viewport.x + scene0.viewport.width * 0.1;
    viewport.y = scene0.viewport.y + scene0.viewport.height * 0.1;
    viewport.width = scene0.viewport.width * 0.4;
    viewport.height = scene0.viewport.height * 0.4;

    scene1.viewport = viewport;
}

resize();

if (Cesium.defined(window.addEventListener)) {
    window.addEventListener('resize', resize, false);
}

viewer.entities.add({
    name : 'Red box with black outline',
    position: Cesium.Cartesian3.fromDegrees(-107.0, 40.0, 300000.0),
    box : {
        dimensions : new Cesium.Cartesian3(400000.0, 300000.0, 500000.0),
        material : Cesium.Color.RED.withAlpha(0.5),
        outline : true,
        outlineColor : Cesium.Color.BLACK
    }
});

// TODO: fix picking and pick depth
/*
function createModel(scene, url, height, heading, pitch, roll) {
    height = Cesium.defaultValue(height, 0.0);
    heading = Cesium.defaultValue(heading, 0.0);
    pitch = Cesium.defaultValue(pitch, 0.0);
    roll = Cesium.defaultValue(roll, 0.0);
    var hpr = new Cesium.HeadingPitchRoll(heading, pitch, roll);

    var origin = Cesium.Cartesian3.fromDegrees(-123.0744619, 44.0503706, height);
    var modelMatrix = Cesium.Transforms.headingPitchRollToFixedFrame(origin, hpr);

    scene.primitives.removeAll(); // Remove previous model
    var model = scene.primitives.add(Cesium.Model.fromGltf({
        url : url,
        modelMatrix : modelMatrix,
        minimumPixelSize : 128
    }));

    model.readyPromise.then(function(model) {
        // Play and loop all animations at half-speed
        model.activeAnimations.addAll({
            speedup : 0.5,
            loop : Cesium.ModelAnimationLoop.REPEAT
        });

        var camera = scene.camera;

        // Zoom to model
        var controller = scene.screenSpaceCameraController;
        var r = 2.0 * Math.max(model.boundingSphere.radius, camera.frustum.near);
        controller.minimumZoomDistance = r * 0.5;

        var center = Cesium.Matrix4.multiplyByPoint(model.modelMatrix, model.boundingSphere.center, new Cesium.Cartesian3());
        var heading = Cesium.Math.toRadians(230.0);
        var pitch = Cesium.Math.toRadians(-20.0);
        camera.lookAt(center, new Cesium.HeadingPitchRange(heading, pitch, r * 2.0));
    }).otherwise(function(error){
        window.alert(error);
    });

    return model;
}

function createLabel(scene) {
    var labels = scene.primitives.add(new Cesium.LabelCollection());
    return labels.add({
        show : false,
        showBackground : true,
        font : '14px monospace',
        horizontalOrigin : Cesium.HorizontalOrigin.LEFT,
        verticalOrigin : Cesium.VerticalOrigin.TOP,
        pixelOffset : new Cesium.Cartesian2(15, 0)
    });
}

Sandcastle.addToolbarButton('Pick position', function() {
    var uri = '../../SampleData/models/CesiumMilkTruck/CesiumMilkTruck-kmc.gltf';
    var model0 = createModel(scene0, uri);
    var model1 = createModel(scene1, uri);

    var label0 = createLabel(scene0);
    var label1 = createLabel(scene1);

    label0.sceneRef = scene0;
    label1.sceneRef = scene1;

    // Mouse over the globe to see the cartographic position
    var handler = new Cesium.ScreenSpaceEventHandler(sceneManager.canvas);
    handler.setInputAction(function(movement) {
        var length = sceneManager.length;
        for (var i = 0; i < length; ++i) {
            var foundPosition = false;

            var scene = sceneManager.get(i);
            if (scene.mode !== Cesium.SceneMode.MORPHING) {
                var pickedObject = scene.pick(movement.endPosition);
                if (scene.pickPositionSupported && Cesium.defined(pickedObject) && (pickedObject.id === model0 || pickedObject.id === model1)) {
                    var cartesian = viewer.scene.pickPosition(movement.endPosition);

                    if (Cesium.defined(cartesian)) {
                        var cartographic = Cesium.Cartographic.fromCartesian(cartesian);
                        var longitudeString = Cesium.Math.toDegrees(cartographic.longitude).toFixed(2);
                        var latitudeString = Cesium.Math.toDegrees(cartographic.latitude).toFixed(2);
                        var heightString = cartographic.height.toFixed(2);

                        //labelEntity.position = cartesian;
                        //labelEntity.label.show = true;
                        //labelEntity.label.text =
                        //    'Lon: ' + ('   ' + longitudeString).slice(-7) + '\u00B0' +
                        //    '\nLat: ' + ('   ' + latitudeString).slice(-7) + '\u00B0' +
                        //    '\nAlt: ' + ('   ' + heightString).slice(-7) + 'm';

                        //labelEntity.label.eyeOffset = new Cesium.Cartesian3(0.0, 0.0, -cartographic.height * (scene.mode === Cesium.SceneMode.SCENE2D ? 1.5 : 1.0));

                        console.log('Lon: ' + ('   ' + longitudeString).slice(-7) + '\u00B0' +
                                    '\nLat: ' + ('   ' + latitudeString).slice(-7) + '\u00B0' +
                                    '\nAlt: ' + ('   ' + heightString).slice(-7) + 'm');
                        foundPosition = true;
                    }
                }
            }

            //if (!foundPosition) {
            //    labelEntity.label.show = false;
            //}
        }
    }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
});
*/

//Sandcastle_End
    Sandcastle.finishedLoading();
}
if (typeof Cesium !== "undefined") {
    startup(Cesium);
} else if (typeof require === "function") {
    require(["Cesium"], startup);
}
</script>
</body>
</html>
